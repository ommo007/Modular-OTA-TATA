name: Supabase OTA Upload

on:
  push:
    branches: [ main ]
    paths:
      - 'mock_drivers/**'
  workflow_dispatch:
    inputs:
      modules:
        description: 'Comma-separated list of modules to deploy (leave empty for all changed)'
        required: false
        type: string
      force_version:
        description: 'Force a specific version (e.g., 1.3.0)'
        required: false
        type: string

env:
  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
  SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}

jobs:
  upload-modules:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Create Upload Configuration
      run: |
        cat > upload-config.yml << 'EOF'
        # Supabase OTA Upload Configuration
        
        supabase:
          bucket_name: "ota-modules"
          endpoints:
            storage: "/storage/v1/object"
            manifest: "manifest.json"
        
        modules:
          speed_governor:
            name: "speed_governor"
            description: "Speed governor module for TATA EV"
            priority: "high"
            build_target: "speed_governor.bin"
            
          distance_sensor:
            name: "distance_sensor" 
            description: "Distance sensor module"
            priority: "normal"
            build_target: "distance_sensor.bin"
        
        versioning:
          scheme: "major.minor.patch"
          auto_increment: true
          base_version: "1.2"
        
        paths:
          latest: "latest"
          versioned: "{module}/{version}"
          manifest: "manifest.json"
        
        metadata_template:
          module_name: "{module}"
          version: "{version}"
          sha256: "{hash}"
          signature: "placeholder-for-demo-signature"
          build_time: "{timestamp}"
          commit_hash: "{commit}"
          priority: "{priority}"
        EOF

    - name: Find changed modules
      id: changed_modules
      uses: tj-actions/changed-files@v41
      with:
        files: mock_drivers/**

    - name: Setup ESP32 Toolchain
      if: steps.changed_modules.outputs.any_changed == 'true' || github.event_name == 'workflow_dispatch'
      run: |
        sudo apt-get update
        sudo apt-get install -y wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 jq yq
        
        mkdir -p ~/.espressif
        cd ~/.espressif
        wget https://dl.espressif.com/dl/xtensa-esp32-elf-gcc8_4_0-esp-2021r2-linux-amd64.tar.gz
        tar -xzf xtensa-esp32-elf-gcc8_4_0-esp-2021r2-linux-amd64.tar.gz
        echo "$HOME/.espressif/xtensa-esp32-elf/bin" >> $GITHUB_PATH

    - name: Validate Secrets
      run: |
        if [ -z "$SUPABASE_URL" ] || [ -z "$SUPABASE_SERVICE_KEY" ]; then
          echo "‚ùå Error: Missing Supabase secrets!"
          echo "Please set SUPABASE_URL and SUPABASE_SERVICE_KEY in repository secrets"
          echo "See SETUP_SECRETS.md for instructions"
          exit 1
        fi
        
        echo "‚úÖ Supabase URL: $SUPABASE_URL"
        echo "‚úÖ Service key: ${#SUPABASE_SERVICE_KEY} characters"

    - name: Build and Upload Modules
      run: |
        # Load configuration
        BUCKET_NAME=$(yq '.supabase.bucket_name' upload-config.yml)
        BASE_VERSION=$(yq '.versioning.base_version' upload-config.yml)
        
        # Determine modules to process
        if [ "${{ github.event.inputs.modules }}" != "" ]; then
          IFS=',' read -ra MODULES <<< "${{ github.event.inputs.modules }}"
        else
          # Find changed modules
          MODULES=()
          for file in ${{ steps.changed_modules.outputs.all_changed_files }}; do
            if [[ $file == mock_drivers/* ]]; then
              module_name=$(echo "$file" | cut -d'/' -f2)
              if [[ ! " ${MODULES[@]} " =~ " ${module_name} " ]]; then
                MODULES+=("$module_name")
              fi
            fi
          done
        fi
        
        if [ ${#MODULES[@]} -eq 0 ]; then
          echo "‚ÑπÔ∏è No modules to process"
          exit 0
        fi
        
        echo "üöÄ Processing modules: ${MODULES[@]}"
        
        # Generate version
        if [ "${{ github.event.inputs.force_version }}" != "" ]; then
          VERSION="${{ github.event.inputs.force_version }}"
        else
          VERSION="${BASE_VERSION}.${{ github.run_number }}"
        fi
        
        echo "üìã Using version: $VERSION"
        
        MANIFEST_UPDATES=""
        
        for module in "${MODULES[@]}"; do
          echo "üî® Building $module..."
          
          # Check if module exists in config
          if ! yq -e ".modules.$module" upload-config.yml > /dev/null; then
            echo "‚ö†Ô∏è Module $module not found in config, using defaults"
            PRIORITY="normal"
            DESCRIPTION="Auto-detected module"
          else
            PRIORITY=$(yq ".modules.$module.priority" upload-config.yml)
            DESCRIPTION=$(yq ".modules.$module.description" upload-config.yml)
          fi
          
          cd "mock_drivers/$module"
          
          # Build
          export PATH="$HOME/.espressif/xtensa-esp32-elf/bin:$PATH"
          make clean && make build
          
          if [ ! -f "build/$module.bin" ]; then
            echo "‚ùå Build failed for $module"
            exit 1
          fi
          
          # Generate metadata
          HASH=$(sha256sum "build/$module.bin" | cut -d' ' -f1)
          SIZE=$(stat -c%s "build/$module.bin")
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          COMMIT=$(git rev-parse HEAD)
          
          # Create metadata JSON
          jq -n \
            --arg name "$module" \
            --arg ver "$VERSION" \
            --arg hash "$HASH" \
            --arg sig "placeholder-for-demo-signature" \
            --arg time "$TIMESTAMP" \
            --arg commit "$COMMIT" \
            --arg priority "$PRIORITY" \
            --arg desc "$DESCRIPTION" \
            --argjson size "$SIZE" \
            '{
              module_name: $name,
              version: $ver,
              sha256: $hash,
              signature: $sig,
              build_time: $time,
              commit_hash: $commit,
              priority: $priority,
              description: $desc,
              size: $size
            }' > build/metadata.json
          
          echo "üì§ Uploading $module v$VERSION..."
          
          # Upload binary to latest
          curl -f -X POST \
            "$SUPABASE_URL/storage/v1/object/$BUCKET_NAME/$module/latest/$module.bin" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
            -H "Content-Type: application/octet-stream" \
            -H "x-upsert: true" \
            --data-binary @"build/$module.bin"
          
          # Upload metadata to latest
          curl -f -X POST \
            "$SUPABASE_URL/storage/v1/object/$BUCKET_NAME/$module/latest/metadata.json" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
            -H "Content-Type: application/json" \
            -H "x-upsert: true" \
            --data-binary @build/metadata.json
          
          # Upload to versioned path
          curl -f -X POST \
            "$SUPABASE_URL/storage/v1/object/$BUCKET_NAME/$module/$VERSION/$module.bin" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
            -H "Content-Type: application/octet-stream" \
            --data-binary @"build/$module.bin"
          
          curl -f -X POST \
            "$SUPABASE_URL/storage/v1/object/$BUCKET_NAME/$module/$VERSION/metadata.json" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
            -H "Content-Type: application/json" \
            --data-binary @build/metadata.json
          
          echo "‚úÖ Uploaded $module v$VERSION"
          
          # Prepare manifest update
          MANIFEST_UPDATE=$(jq -n \
            --arg module "$module" \
            --arg ver "$VERSION" \
            --arg desc "$DESCRIPTION" \
            --arg priority "$PRIORITY" \
            --arg time "$TIMESTAMP" \
            '.[$module] = {
              latest_version: $ver,
              path: ("/" + $module + "/"),
              description: $desc,
              priority: $priority,
              last_updated: $time
            }')
          
          if [ -z "$MANIFEST_UPDATES" ]; then
            MANIFEST_UPDATES="$MANIFEST_UPDATE"
          else
            MANIFEST_UPDATES=$(echo "$MANIFEST_UPDATES $MANIFEST_UPDATE" | jq -s 'add')
          fi
          
          cd ../..
        done
        
        # Update manifest
        echo "üìã Updating manifest..."
        
        # Download current manifest
        curl -o current_manifest.json \
          "$SUPABASE_URL/storage/v1/object/$BUCKET_NAME/manifest.json" \
          -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" || echo "{}" > current_manifest.json
        
        # Merge updates
        UPDATED_MANIFEST=$(echo "$MANIFEST_UPDATES" | jq -s --slurpfile current current_manifest.json 'add as $updates | $current[0] * $updates')
        echo "$UPDATED_MANIFEST" > updated_manifest.json
        
        # Upload updated manifest
        curl -f -X POST \
          "$SUPABASE_URL/storage/v1/object/$BUCKET_NAME/manifest.json" \
          -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
          -H "Content-Type: application/json" \
          -H "x-upsert: true" \
          --data-binary @updated_manifest.json
        
        echo "üéâ Successfully uploaded modules: ${MODULES[@]}"
        echo "üìä Version: $VERSION"
        
        # Clean up
        rm -f upload-config.yml current_manifest.json updated_manifest.json 