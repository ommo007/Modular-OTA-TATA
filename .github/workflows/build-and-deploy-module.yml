name: Build and Deploy Module

on:
  push:
    branches: [ main ]
    paths:
      - 'mock_drivers/**'
  workflow_dispatch:

env:
  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
  SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}

jobs:
  build_and_deploy_modules:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Find changed modules
      id: changed_modules
      uses: tj-actions/changed-files@v41
      with:
        files: mock_drivers/**

    - name: Setup ESP-IDF
      if: steps.changed_modules.outputs.any_changed == 'true'
      uses: espressif/esp-idf-ci-action@v1
      with:
        esp_idf_version: v5.1.2
        target: esp32

    - name: Build and Deploy Each Changed Module
      if: steps.changed_modules.outputs.any_changed == 'true'
      env:
        # For the security signing step, you would create these secrets in GitHub
        #SIGNING_PRIVATE_KEY: ${{ secrets.SIGNING_PRIVATE_KEY }}
        CHANGED_FILES: ${{ steps.changed_modules.outputs.all_changed_files }}
      run: |
        # Use a script to handle the logic for each changed module
        # This is cleaner than a complex matrix strategy for this use case
        # Create the script
        cat > deploy_script.sh << 'EOF'
        #!/bin/bash
        set -e
        # Create an array of unique module directories that have changed
        declare -A modules_to_build
        for file in $CHANGED_FILES; do
          if [[ $file == mock_drivers/* ]]; then
            module_name=$(echo "$file" | cut -d'/' -f2)
            modules_to_build["$module_name"]=1
          fi
        done

        if [ ${#modules_to_build[@]} -eq 0 ]; then
            echo "No changes in mock_drivers to process."
            exit 0
        fi

        echo "Modules to process: ${!modules_to_build[@]}"
        MANIFEST_UPDATES=""

        for module in "${!modules_to_build[@]}"; do
            echo "--- Processing module: $module ---"
            cd "mock_drivers/$module"

            # 1. Build module
            make clean && make build
            if [ ! -f "build/$module.bin" ]; then
                echo "Build failed: binary not found for $module"
                exit 1
            fi

            # 2. Package metadata
            VERSION="1.1.${{ github.run_number }}"
            HASH=$(sha256sum "build/$module.bin" | cut -d' ' -f1)
            # --- SECURITY ENHANCEMENT (SIGNING) ---
            # To enable, uncomment the next 3 lines and add the SIGNING_PRIVATE_KEY secret
            # echo "$SIGNING_PRIVATE_KEY" > private_key.pem
            # SIGNATURE=$(echo -n "$HASH" | openssl dgst -sha256 -sign private_key.pem | base64 -w 0)
            # rm private_key.pem
            SIGNATURE="placeholder-for-demo-signature" # Placeholder

            jq -n \
              --arg name "$module" \
              --arg ver "$VERSION" \
              --arg hash "$HASH" \
              --arg sig "$SIGNATURE" \
              '{module_name: $name, version: $ver, sha256: $hash, signature: $sig}' \
              > build/metadata.json
            cat build/metadata.json

            # 3. Upload to Supabase
            curl -f -X POST \
              "$SUPABASE_URL/storage/v1/object/ota-modules/$module/latest/$module.bin" \
              -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
              -H "Content-Type: application/octet-stream" \
              --data-binary @"build/$module.bin"

            curl -f -X POST \
              "$SUPABASE_URL/storage/v1/object/ota-modules/$module/latest/metadata.json" \
              -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
              -H "Content-Type: application/json" \
              --data-binary @build/metadata.json

            # 4. Prepare manifest update
            MANIFEST_UPDATES+=$(jq -n --arg module "$module" --arg ver "$VERSION" \
              '.[$module] = {latest_version: $ver, path: ("/" + $module + "/")}')
            cd ../..
        done

        # 5. Update master manifest
        echo "--- Updating master manifest ---"
        curl -o manifest.json \
          "$SUPABASE_URL/storage/v1/object/ota-modules/manifest.json" \
          -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" || echo "{}" > manifest.json

        UPDATED_MANIFEST=$(echo "$MANIFEST_UPDATES" | jq -s 'add' | jq -s '.[0] * .[1]' manifest.json -)
        echo "$UPDATED_MANIFEST" > manifest_updated.json
        cat manifest_updated.json

        curl -f -X POST \
          "$SUPABASE_URL/storage/v1/object/ota-modules/manifest.json" \
          -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
          -H "Content-Type: application/json" \
          --data-binary @manifest_updated.json

        echo "Manifest updated successfully."
        EOF

        # Run the script
        bash deploy_script.sh 