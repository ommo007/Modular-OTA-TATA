name: 'ğŸš€ Build & Deploy OTA Modules'

# This workflow triggers on pushes to the 'main' branch that affect module code,
# or when manually triggered via the GitHub Actions UI.
on:
  push:
    branches: [ main ]
    paths:
      - 'mock_drivers/**'
  workflow_dispatch:

env:
  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
  SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}

jobs:
  # ===============================================================
  # JOB 1: Build, Test, and Deploy Changed Modules
  # ===============================================================
  build-and-deploy:
    name: 'Build & Deploy Changed Modules'
    runs-on: ubuntu-latest
    
    # Define outputs for this job
    outputs:
      any_changed: ${{ steps.changed_files.outputs.any_changed }}
      modules_deployed: ${{ steps.deploy.outputs.modules_deployed }}

    steps:
      # ---------------------------------------------------------------
      # STEP 1: Checkout Code
      # ---------------------------------------------------------------
      - name: 'ğŸ›’ Checkout Repository'
        uses: actions/checkout@v4
        with:
          # Fetch all history for accurate change detection
          fetch-depth: 0

      # ---------------------------------------------------------------
      # STEP 2: Detect Changed Modules
      # This crucial step identifies which specific module folders
      # have been modified in the latest push, ensuring we only
      # build and deploy what's necessary.
      # ---------------------------------------------------------------
      - name: 'ğŸ” Detect Changed Module Files'
        id: changed_files
        uses: tj-actions/changed-files@v41
        with:
          files: mock_drivers/**

      # ---------------------------------------------------------------
      # STEP 3: Setup ESP32 Toolchain
      # The toolchain is required to compile the C code for the ESP32.
      # This step is skipped if no modules were changed.
      # ---------------------------------------------------------------
      - name: 'ğŸ› ï¸ Setup ESP32 Toolchain'
        if: steps.changed_files.outputs.any_changed == 'true'
        run: |
          # Install ESP32 toolchain for building mock drivers
          sudo apt-get update
          sudo apt-get install -y wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 jq
          
          # Download and install ESP32 toolchain
          mkdir -p ~/.espressif
          cd ~/.espressif
          wget https://dl.espressif.com/dl/xtensa-esp32-elf-gcc8_4_0-esp-2021r2-linux-amd64.tar.gz
          tar -xzf xtensa-esp32-elf-gcc8_4_0-esp-2021r2-linux-amd64.tar.gz
          
          # Add toolchain to PATH
          echo "$HOME/.espressif/xtensa-esp32-elf/bin" >> $GITHUB_PATH
          
          # Verify toolchain installation
          export PATH="$HOME/.espressif/xtensa-esp32-elf/bin:$PATH"
          xtensa-esp32-elf-gcc --version

      # ---------------------------------------------------------------
      # STEP 4: Validate Required Environment Variables
      # Ensure we have all the secrets needed for deployment
      # ---------------------------------------------------------------
      - name: 'ğŸ” Validate Environment Variables'
        if: steps.changed_files.outputs.any_changed == 'true'
        run: |
          if [ -z "$SUPABASE_URL" ] || [ -z "$SUPABASE_SERVICE_KEY" ]; then
            echo "âŒ Error: Missing required secrets"
            echo "Please ensure SUPABASE_URL and SUPABASE_SERVICE_KEY are set in repository secrets"
            exit 1
          fi
          echo "âœ… Environment variables validated"

      # ---------------------------------------------------------------
      # STEP 5: Make Deployment Script Executable
      # ---------------------------------------------------------------
      - name: 'ğŸ”§ Prepare Deployment Script'
        if: steps.changed_files.outputs.any_changed == 'true'
        run: |
          chmod +x ./scripts/deploy-to-supabase.sh
          echo "âœ… Deployment script is ready"

      # ---------------------------------------------------------------
      # STEP 6: Execute Intelligent Deployment Script
      # This is the core step. It runs our intelligent bash script,
      # which handles build, versioning, metadata generation, conflict
      # resolution, and cloud upload automatically.
      # ---------------------------------------------------------------
      - name: 'ğŸš€ Deploy Modules with Auto-Versioning'
        id: deploy
        if: steps.changed_files.outputs.any_changed == 'true'
        env:
          # Pass GitHub context for version generation
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_REF: ${{ github.ref }}
        run: |
          echo "ğŸ” Changed files: ${{ steps.changed_files.outputs.all_changed_files }}"
          echo "ğŸ—ï¸ Starting intelligent deployment process..."
          
          # Run the intelligent deployment script with changed files as arguments
          ./scripts/deploy-to-supabase.sh ${{ steps.changed_files.outputs.all_changed_files }}
          
          # Extract deployed modules for output
          echo "modules_deployed=true" >> $GITHUB_OUTPUT

      # ---------------------------------------------------------------
      # STEP 7: Report Deployment Summary
      # Provides a clear summary of the job's outcome in the logs.
      # ---------------------------------------------------------------
      - name: 'ğŸ“Š Report Deployment Summary'
        if: always() # This step runs even if previous steps fail
        run: |
          echo "=========================================="
          echo "ğŸ¯ DEPLOYMENT SUMMARY"
          echo "=========================================="
          
          if [ "${{ steps.changed_files.outputs.any_changed }}" == 'true' ]; then
            if [ "${{ job.status }}" == "success" ]; then
              echo "âœ… SUCCESS: All changed modules deployed successfully"
              echo "ğŸ”— Supabase Storage: ${{ env.SUPABASE_URL }}/dashboard/project/_/storage/buckets/ota-modules"
              echo ""
              echo "ğŸ“¦ Changed Files:"
              echo "${{ steps.changed_files.outputs.all_changed_files }}" | tr ' ' '\n' | while read file; do
                echo "  â€¢ $file"
              done
              echo ""
              echo "ğŸš€ Modules are now available for OTA updates!"
            else
              echo "âŒ FAILED: Deployment encountered errors"
              echo "Check the logs above for detailed error information"
            fi
          else
            echo "â„¹ï¸  INFO: No module changes detected"
            echo "No deployment was necessary for this push"
          fi
          
          echo "=========================================="

  # ===============================================================
  # JOB 2: Post-Deployment Validation (Optional)
  # This job runs after successful deployment to validate uploads
  # ===============================================================
  validate-deployment:
    name: 'Validate Deployment'
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: needs.build-and-deploy.outputs.modules_deployed == 'true' && needs.build-and-deploy.result == 'success'
    
    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}

    steps:
      - name: 'âœ… Validate Manifest Accessibility'
        run: |
          echo "ğŸ” Checking if manifest is accessible..."
          
          # Test if manifest.json is accessible
          if curl -f -s "${{ env.SUPABASE_URL }}/storage/v1/object/ota-modules/manifest.json" \
             -H "Authorization: Bearer ${{ env.SUPABASE_SERVICE_KEY }}" > /dev/null; then
            echo "âœ… Manifest is accessible"
          else
            echo "âš ï¸  Warning: Manifest may not be accessible"
          fi
          
          echo "ğŸ‰ Deployment validation completed" 