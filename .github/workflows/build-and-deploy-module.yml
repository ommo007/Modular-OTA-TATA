name: Build and Deploy Module

on:
  push:
    branches: [ main ]
    paths:
      - 'mock_drivers/**'
  workflow_dispatch:

env:
  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
  SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}

jobs:
  build_and_deploy_modules:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Find changed modules
      id: changed_modules
      uses: tj-actions/changed-files@v41
      with:
        files: mock_drivers/**

    - name: Setup ESP32 Toolchain
      if: steps.changed_modules.outputs.any_changed == 'true'
      run: |
        # Install ESP32 toolchain for building mock drivers
        sudo apt-get update
        sudo apt-get install -y wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 jq
        
        # Download and install ESP32 toolchain
        mkdir -p ~/.espressif
        cd ~/.espressif
        wget https://dl.espressif.com/dl/xtensa-esp32-elf-gcc8_4_0-esp-2021r2-linux-amd64.tar.gz
        tar -xzf xtensa-esp32-elf-gcc8_4_0-esp-2021r2-linux-amd64.tar.gz
        
        # Add toolchain to PATH
        echo "$HOME/.espressif/xtensa-esp32-elf/bin" >> $GITHUB_PATH
        
        # Verify toolchain installation
        export PATH="$HOME/.espressif/xtensa-esp32-elf/bin:$PATH"
        xtensa-esp32-elf-gcc --version

    - name: Build and Deploy Each Changed Module
      if: steps.changed_modules.outputs.any_changed == 'true'
      env:
        # We still define them here for context, but will pass them as args
        SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
        SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        CHANGED_FILES: ${{ steps.changed_modules.outputs.all_changed_files }}
      run: |
        # Create the deployment script
        cat > deploy_script.sh << 'EOF'
        #!/bin/bash
        set -e

        # The script now accepts secrets as arguments
        SUPABASE_URL="$1"
        SUPABASE_SERVICE_KEY="$2"

        if [ -z "$SUPABASE_URL" ] || [ -z "$SUPABASE_SERVICE_KEY" ]; then
            echo "Error: Supabase URL or Service Key not provided to script."
            echo "URL length: ${#SUPABASE_URL} characters"
            echo "Key length: ${#SUPABASE_SERVICE_KEY} characters"
            exit 1
        fi

        echo "Using Supabase URL: $SUPABASE_URL"
        echo "Service key provided: ${#SUPABASE_SERVICE_KEY} characters"

        # Create an array of unique module directories that have changed
        declare -A modules_to_build
        for file in $CHANGED_FILES; do
          if [[ $file == mock_drivers/* ]]; then
            module_name=$(echo "$file" | cut -d'/' -f2)
            modules_to_build["$module_name"]=1
          fi
        done

        if [ ${#modules_to_build[@]} -eq 0 ]; then
            echo "No changes in mock_drivers to process."
            exit 0
        fi

        echo "Modules to process: ${!modules_to_build[@]}"
        MANIFEST_UPDATES=""

        for module in "${!modules_to_build[@]}"; do
            echo "--- Processing module: $module ---"
            cd "mock_drivers/$module"

            # 1. Build module (ensure toolchain is in PATH)
            export PATH="$HOME/.espressif/xtensa-esp32-elf/bin:$PATH"
            make clean && make build
            if [ ! -f "build/$module.bin" ]; then
                echo "Build failed: binary not found for $module"
                exit 1
            fi

            # 2. Package metadata
            VERSION="1.2.${{ github.run_number }}" # Incrementing minor version for clarity
            HASH=$(sha256sum "build/$module.bin" | cut -d' ' -f1)
            # --- SECURITY ENHANCEMENT (SIGNING) ---
            # To enable, uncomment the next 3 lines and add the SIGNING_PRIVATE_KEY secret
            # echo "$SIGNING_PRIVATE_KEY" > private_key.pem
            # SIGNATURE=$(echo -n "$HASH" | openssl dgst -sha256 -sign private_key.pem | base64 -w 0)
            # rm private_key.pem
            SIGNATURE="placeholder-for-demo-signature" # Placeholder

            jq -n \
              --arg name "$module" \
              --arg ver "$VERSION" \
              --arg hash "$HASH" \
              --arg sig "$SIGNATURE" \
              '{module_name: $name, version: $ver, sha256: $hash, signature: $sig}' \
              > build/metadata.json
            cat build/metadata.json

            # 3. Upload to Supabase using secrets passed as arguments
            echo "Uploading binary for $module..."
            curl -f -X POST \
              "$SUPABASE_URL/storage/v1/object/ota-modules/$module/latest/$module.bin" \
              -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
              -H "Content-Type: application/octet-stream" \
              --data-binary @"build/$module.bin"

            echo "Uploading metadata for $module..."
            curl -f -X POST \
              "$SUPABASE_URL/storage/v1/object/ota-modules/$module/latest/metadata.json" \
              -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
              -H "Content-Type: application/json" \
              --data-binary @build/metadata.json

            # 4. Prepare manifest update
            MANIFEST_UPDATES+=$(jq -n --arg module "$module" --arg ver "$VERSION" \
              '.[$module] = {latest_version: $ver, path: ("/" + $module + "/")}')
            cd ../..
        done

        # 5. Update master manifest
        echo "--- Updating master manifest ---"
        curl -o manifest.json \
          "$SUPABASE_URL/storage/v1/object/ota-modules/manifest.json" \
          -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" || echo "{}" > manifest.json

        UPDATED_MANIFEST=$(echo "$MANIFEST_UPDATES" | jq -s 'add' | jq -s '.[0] * .[1]' manifest.json -)
        echo "$UPDATED_MANIFEST" > manifest_updated.json
        cat manifest_updated.json

        curl -f -X POST \
          "$SUPABASE_URL/storage/v1/object/ota-modules/manifest.json" \
          -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
          -H "Content-Type: application/json" \
          --data-binary @manifest_updated.json

        echo "Manifest updated successfully."
        EOF

        # Make the script executable and run it, passing secrets as arguments
        chmod +x deploy_script.sh
        ./deploy_script.sh "${{ secrets.SUPABASE_URL }}" "${{ secrets.SUPABASE_SERVICE_KEY }}" 